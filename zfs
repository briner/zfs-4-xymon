#!/usr/bin/python
# -*- coding: utf-8 -*-
'''Displays each ZFS pool name with capacity and status'''

# 02.02.2010 Cedric.Briner@unige.ch
#            created
#
# more info on http://hobbitmon.sourceforge.net/docs/man8/hobbitd_rrd.8.html
# by using the method "CUSTOM RRD DATA VIA SCRIPTS"

# imports
import sys, os
import math
import datetime
import subprocess as s
import re
import zfs_cfg

HOBBIT_TESTNAME="zfs"

ZPOOL_CMD="/usr/sbin/zpool list -o name,size,used,available,capacity,health"
ZFS_LIST_CMD="zfs list -H -t filesystem | cut -f1"
ZFS_GET_CMD="zfs get -H -p used,available %s | cut -f2-3 "
ZPOOL_STATUS_XV='/usr/sbin/zpool status -xv'

PAGE_COLOR='green'


# class about config
class Size(long):
   import math
   power={'K':3, 'M':6, 'G':9, 'T':12, 'P':15}
   rev_power={3:'K', 6:'M', 9:'G', 12:'T', 15:'P'}
   def __new__(cls, str_size):
      if type(str_size) == Size:
         return str_size
      if type(str_size) in [str]:
         str_size=long( float(str_size[:-1])*10**cls.power[str_size[-1]] )
      if type(str_size) in [int, float, long]:
         inst=long(str_size)
      else:
         raise Exception.ValueError()
      ret=long.__new__( cls, (inst) )
      return ret
   def __str__(self):
      eng_power=(math.floor(math.log10 (self)/3))*3
      ret=float(self)/10.**eng_power
      return '%.2f' % ret+self.rev_power[eng_power]
   def str_long(self):
      return long(self)


class ZfsTresholdName(str):
   '''this class allow to compile once the RE'''
   def __new__(cls,  zfs_name):
      ret=str.__new__( cls, (zfs_name) )
      ret.re_str='^%s$'%zfs_name
      ret.re=re.compile(ret.re_str)
      return ret

class TreshHold(list):
   '''this class is used with the configuration'''
   def __init__(self, yellow,red):
      self.default=[yellow,red]
      super(TreshHold,self).__init__()
   def append(self, name, yellow, red):
      name=ZfsTresholdName(name)
      super(TreshHold,self).append([name, yellow, red])
   def value_yellow_red2color(value, yellow, red):
      ret='green'
      if value >= yellow:
         ret='yellow'
      if value >= red:
         ret='red'
      return ret
   def get_color(name, value):
      # default value
      ret=self.value_yellow_red2color(value, *self.default)
      # check the other possibilities
      for zpool_treshold_name, yellow, red in self:
         if zpool_treshold_name.re.match(zpool_name):            
            ret_value=self.value_yellow_red2color(value, yellow, red)
            break

# parse and read the config

CAPACITY_TRESHOLD=TreshHold( *zfs_cfg.CAPACITY_TRESHOLD )
for config in zfs_cfg.LCAPACITY_TRESHOLD_TUNING:
   CAPACITY_TRESHOLD.append( *config )

#
# definition and classes and populate them
#

def add_color(first, second):
   lcolor=['green', 'yellow', 'red']
   ifirst=lcolor.index(first)
   isecond=lcolor.index(second)
   if ifirst >= isecond:
      return first
   return second

class Zfs(object):
   def __init__(self, name):
      self.name=name
      self.lchild=[]
   def __repr__(self):
      return "zfs(%s)"%self.name
   def get_used_2(self):
      ret=self.used
      for child in self.lchild:
         ret-=child.used_2
      ret=Size(ret)
      return ret
   used_2=property(get_used_2)
   def get_cap_2(self):
      return float(self.used_2)/float(self.zpool.size)*100
   cap_2=property(get_cap_2)
   def get_ldescendant(self):
      descent=self.lchild[:]
      for child in self.lchild:
         descent+=child.ldescendant
      return descent
   ldescendant=property(get_ldescendant)
   
      

def cmp_name(self,other):
      if not isinstance(other, Zfs):
         return -1
      lself=self.name.split('/')
      lother=other.name.split('/')
      for i in range(min(len(lself),len(lother))):
         ret=cmp(lself[i], lother[i])
         if ret != 0:
            return ret
      if len(lself) > len(lother):
         return 1
      else:
         return -1

def populate_zfs():
   #get the list of all zfs
   dzfs={}
   q=s.Popen(ZFS_LIST_CMD, stdout=s.PIPE, shell=True)
   lzfsname=q.stdout.readlines()
   for zfsname in lzfsname:
      zfs=Zfs(zfsname.rstrip())
      dzfs[zfs.name]=zfs
      tmp_cmd=ZFS_GET_CMD %  zfs.name
      q=s.Popen(tmp_cmd, stdout=s.PIPE, shell=True)
      lget=q.stdout.readlines()
      for get in lget:
         # get: used    8493892096
         get=get.rstrip()
         (prop_name, prop_value )=get.split()
         if prop_name in ['size', 'used', 'available']:
            prop_value=Size(long(prop_value))
         setattr(zfs, prop_name, prop_value)
   #construct the child depedencies for zfs
   for zfsname, zfs in dzfs.iteritems():
      lpath_elem=zfsname.split('/')
      if len(lpath_elem) > 1:
         for i in range(len(lpath_elem)-1):
            subpath='/'.join(lpath_elem[:i+1])
            dzfs[subpath].lchild.append(zfs)   
   return dzfs
   
dzfs=populate_zfs()

class Zpool(object):
   HEALTH_GREEN='ONLINE'
   def __init__(self, name, size, used, avail, cap, health, zfs):
      '''header     = "NAME       SIZE  USED  AVAIL CAP HEALTH"
      zfs_output = "mediadev_pool 49.2G 7.92G 41.3G 16% ONLINE" '''
      # find the index for each parameter
      self.zfs=zfs
      self.name=name
      self.size=Size(size)
      self.used=Size(self.zfs.used)
      self.used_2=Size(self.zfs.used_2)
      self.avail=Size(avail)
      self.cap=cap
      self.cap_2=float(self.used_2)/float(self.size)*100
      self.health=health
      self.color=self.calculate_color()     
   def get_lzfs(self):
      return [self.zfs]+self.zfs.ldescendant
   def __repr__(self):
      return "zpool(%s)" % self.name
   def calculate_color(self):
      if self.health != self.HEALTH_GREEN:
         return 'red'
      # load the default config
      default_treshold=CAPACITY_TRESHOLD.default
      # check if there is specific configuration
      for zpool_treshold_name, yellow, red in CAPACITY_TRESHOLD:
         if zpool_treshold_name.re.match(zpool_name):
            default_treshold=(yellow, red)
            break
      # in which state are we (green, yellow, red)
      if self.cap > default_treshold[1]:
         return 'red'
      if self.cap > default_treshold[0]:
         return 'yellow'
      return 'green'


def populate_zpool():
   lzpool=[]
   q=s.Popen(ZPOOL_CMD, stdout=s.PIPE, shell=True)
   header=q.stdout.readline()
   lheader=header.split()
   lentry=q.stdout.readlines()
   #parse zpool_cmd output
   #     header = "NAME          SIZE  USED  AVAIL CAP HEALTH
   # zfs_output = "mediadev_pool 49.2G 7.92G 41.3G 16% ONLINE"
   for entry in lentry:
      lvalue=entry.split()
      zfs_root=dzfs[lvalue[lheader.index('NAME')]]
      zpool=Zpool(lvalue[lheader.index('NAME')]
                 ,lvalue[lheader.index('SIZE')]
                 ,lvalue[lheader.index('USED')]
                 ,lvalue[lheader.index('AVAIL')]
                 ,int( lvalue[lheader.index('CAP')][0:-1]) # cap is 16 and not '16%'
                 ,lvalue[lheader.index('HEALTH')]
                 ,zfs_root
                 )
      for zfs in [zfs_root]+zfs_root.ldescendant:
         zfs.zpool=zpool
      lzpool.append(zpool)
   return lzpool

class ZpoolStatus(object):
   def __init__(self):
      q=s.Popen(ZPOOL_STATUS_XV, stdout=s.PIPE, shell=True)
      lret=q.stdout.readlines()
      self.lret=[ret.rstrip() for ret in lret]
      self.color='red'
      if len(self.lret) == 1:
         if self.lret[0]=='all pools are healthy':
            self.color='green'
zpool_status=ZpoolStatus()
PAGE_COLOR=add_color(PAGE_COLOR, zpool_status.color)


#use the class
lzpool=populate_zpool()
# change PAGE_COLOR
for zpool in lzpool:
   PAGE_COLOR=add_color(PAGE_COLOR, zpool.color)

def show_in_xymon():
   ret='<table>\
 <tr><td>name</td>\
 <td align="right">size</td>\
 <td align="right">used</td>\
 <td align="right">used_2</td>\
 <td align="right">avail</td>\
 <td align="right">cap</td>\
 <td align="right">cap_2</td>\
 <td align="right">health</td>\
 </tr>'
   for zpool in lzpool:
      ret+='\n <!--LineToGraph:zfs_v1.1 name:%(name)s cap:%(cap)s cap_2:%(cap_2).2f -->' %{
          'name': zpool.name
         ,'cap': zpool.cap
         ,'cap_2': float(zpool.used_2)/float(zpool.size)*100
         }
      ret+='\n <!--name--><tr><td>&%(color)s %(name)s</td>\
 <!--size--><td align="right"> %(size)s</td>\
 <!--used--><td align="right"> %(used)s</td>\
 <!--used_2--><td align="right"> %(used_2)s</td>\
 <!--avail--><td align="right"> %(avail)s</td>\
 <!--cap--><td align="right"> %(cap)s%%</td>\
 <!--cap_2--><td align="right"> %(cap_2).2f%%</td>\
 <!--health--><td align="right"> %(health)s</td>\
 </tr>' %{
          'color': zpool.color
         ,'name': zpool.name
         ,'size': zpool.size
         ,'used': zpool.used
         ,'used_2': zpool.used_2
         ,'avail': zpool.avail
         ,'cap': zpool.cap
         ,'cap_2': float(zpool.used_2)/float(zpool.size)*100
         ,'health': zpool.health
         }
      zpool.zfs.lchild.sort(cmp_name)
      for zfs in zpool.zfs.lchild:
         ret+='\n  <!--LineToGraph:zfs_v1.2 name:%(name)s cap_2:%(cap_2).2f -->' %{
         'name': zfs.name
         ,'cap_2': zfs.cap_2
         }      
         ret+=' <!-- name --><tr><td>%(name)s</td> \
 <!--size--><td align="right"> %(size)s</td>\
 <!--used--><td align="right"> %(used)s</td>\
 <!--used_2--><td align="right"> %(used_2)s</td>\
 <!--avail--><td align="right"> %(avail)s</td>\
 <!--cap--><td align="right"> %(cap)s</td>\
 <!--cap_2--><td align="right"> %(cap_2).2f%%</td>\
 <!--health--><td align="right"> %(health)s</td>\
 </tr>' %{
         'name': '&nbsp;'+zfs.name
         ,'size': ''
         ,'used': zfs.used
         ,'used_2': zfs.used_2
         ,'avail': zfs.available
         ,'cap': ''
         ,'cap_2': zfs.cap_2
         ,'health': ''
         }
   ret+='<tr><td>&%(color)s zpool status -xv</td><td colspan="6">%(lret)s</td></tr>' %{
      'color':zpool_status.color
      ,'lret':'<br/>'.join(zpool_status.lret)}
   ret = ret[:-1]+'</tr></table>\n'
   return ret

table=show_in_xymon()
# Sends status
cmd='%(bbcmd)s %(bbdisp)s "status %(machine)s.%(testname)s %(display_color)s %(date)s \n %(table)s"' % \
    {'bbcmd':os.environ.get('BB','env_of_bb')
    ,'bbdisp':os.environ.get('BBDISP','env_of_bbdisp')
    ,'machine':os.environ.get('MACHINE','env_of_machine')
    ,'testname':HOBBIT_TESTNAME
    ,'date':datetime.datetime.now().strftime('%a, %d %b %Y %H:%M:%S h MET')
    ,'display_color':PAGE_COLOR
    ,'table':table
    }

xymon_launched_this=os.environ.get('BB', None)
if xymon_launched_this:
   os.system(cmd)
else:
   cmd.replace('\n', '\\\n')
   print "command to launch"
   print "-----------------"
   print cmd
   print
   print "table"
   print "-----"
   print table

sys.exit(0)
